/**
 * 
 */
package net.paoding.rose.jade.plugin.sql;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.core.annotation.Order;
import org.springframework.dao.InvalidDataAccessApiUsageException;

import net.paoding.rose.jade.annotation.SQL;
import net.paoding.rose.jade.plugin.sql.dialect.IDialect;
import net.paoding.rose.jade.plugin.sql.dialect.MySQLDialect;
import net.paoding.rose.jade.plugin.sql.mapper.EntityMapperManager;
import net.paoding.rose.jade.plugin.sql.mapper.IOperationMapper;
import net.paoding.rose.jade.plugin.sql.mapper.OperationMapperManager;
import net.paoding.rose.jade.plugin.sql.util.BasicSQLFormatter;
import net.paoding.rose.jade.plugin.sql.util.PlumUtils;
import net.paoding.rose.jade.statement.Interpreter;
import net.paoding.rose.jade.statement.StatementMetaData;
import net.paoding.rose.jade.statement.StatementRuntime;

/**
 * Plum插件用于生成SQL的拦截器。
 * 
 * @author Alan.Geng[gengzhi718@gmail.com]
 */
@Order(-1)
public class PlumSQLInterpreter implements Interpreter, InitializingBean {

    private static final Log logger = LogFactory.getLog(PlumSQLInterpreter.class);

    private OperationMapperManager operationMapperManager;

    private IDialect dialect;

    public void setDialect(IDialect dialect) {
        this.dialect = dialect;
    }

    public void setOperationMapperManager(OperationMapperManager operationMapperManager) {
        this.operationMapperManager = operationMapperManager;
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        if (operationMapperManager == null) {
            operationMapperManager = new OperationMapperManager();
            operationMapperManager.setEntityMapperManager(new EntityMapperManager());
        }
        if (dialect == null) {
            // 未来：不同的DAO方法可以有不同的Dialect哦，而且是自动知道，不需要外部设置。
            dialect = new MySQLDialect();
        }
    }

    /* (non-Javadoc)
     * @see net.paoding.rose.jade.statement.Interpreter#interpret(net.paoding.rose.jade.statement.StatementRuntime)
     */
    @Override
    public void interpret(StatementRuntime runtime) {
        final String interpreterAttribute = "jade-plugin-sql.interpreter";
        Interpreter interpreter = runtime.getMetaData().getAttribute(interpreterAttribute);
        if (interpreter == null) {
            StatementMetaData smd = runtime.getMetaData();
            synchronized (smd) {
                interpreter = smd.getAttribute(interpreterAttribute);
                if (interpreter == null) {
                    interpreter = DO_NOTHING;
                    if (GenericDAO.class.isAssignableFrom(smd.getDAOMetaData().getDAOClass())) {
                        SQL sqlAnnotation = smd.getMethod().getAnnotation(SQL.class);
                        if (sqlAnnotation == null // 没有注解@SQL
                            || PlumUtils.isBlank(sqlAnnotation.value()) // 虽注解但没有写SQL
                            || "jade-plugin-sql".equals(sqlAnnotation.value())) {// 明确表示使用jade-plugin-sql
                            interpreter = new RealInterpreter(operationMapperManager.create(smd));
                        }
                    }
                    smd.setAttribute(interpreterAttribute, interpreter);
                }
            }
        }
        interpreter.interpret(runtime);
    }

    private class RealInterpreter implements Interpreter {
        final IOperationMapper operationMapper;

        public RealInterpreter(IOperationMapper operationMapper) {
            this.operationMapper = operationMapper;
        }

        @Override
        public void interpret(StatementRuntime runtime) {
            try {
                String sql = dialect.translate(operationMapper, runtime);
                if (logger.isInfoEnabled()) {
                    BasicSQLFormatter formatter = new BasicSQLFormatter();
                    logger.info("Plum auto generated by " + dialect.getClass().getSimpleName() + ":"
                                + formatter.format(sql));
                }
                runtime.setSQL(sql);
            } catch (Exception e) {
                throw new InvalidDataAccessApiUsageException(e.getMessage(), e);
            }
        }

    };

    private static final Interpreter DO_NOTHING = new Interpreter() {

        @Override
        public void interpret(StatementRuntime runtime) {
            // do nothing
        }
    };

}
